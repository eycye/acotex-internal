<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #195882;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #195882;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #6793B0;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ACCESS" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d694c63ab398a53b1c71ee8ec300f4277db358b592e74e91e007c2446a22cda61ba63ac4c2a9c48c301277276eb6efc098697e864a0033fbcbdc4969def7d6d09ec1838415a148f465d8d73c007f6c7685e25106efc749cbe7d1f8c6e5a41911c3138d6d62bf1088f35ae6e7440227901fc1acf36b0676a4538f14a96ecf76f6a1c832e9b62c06a2b1d97c2ed93c8623dd0a7adae018a74013ee8bc32312713610407c324ce7a301b902ffe7cdc9b8daf14016ff308711c459f6a21f4b754d922f9937c65cbefb07e92da767cec23f3118a3b4cb68e3c28672c25a57c3e4b1aea19e8b0cf3b05c75869a84762112ba8d1b0f6a40a6b161fd0e30c4184590adb5a133284b7997d9e2bab085bf62c9619e67b545159ea1cdc3c63dfde9c7da38456dc395b15f11e844a203120bcbe9c4c4c99304ebe8470b720f7eada41ba41c9ba0aa4895750092a9a31b94b122016dbcc3471a4f8b486c7888aba0dd930c5821a0675f29db5256655f51f0ea3cdd7b9c6de9618e7e96faf4db3912a28bc0257c5da7910414786741618d6a93fef80dffdba3f099800c75ca7ba6766b35809adcecee0a3d9286d50204e29ff1921d5103cc2e1f795e30cae22e9e4b4fbfdd73e523119d8293ab3a557d01bc37b0730510f9318bdba59d196b201394e1af2edffce174f68091450a1690b2d72ca72831b73e0d425420e8f6221f1f5c70c5f7e0f6b255496f83ad807ef055f931aeeada2329d04d342708c69a123b18fc8735f09417d386a5b7830a1a6204b01a52483a7dac539b8fa5c7e096ac4a0eb365f627b2a457bfc5c6bc92f7b7eb62bd73d092b6012723087b5344298ece4ae1821a921cf179227ba6fdf21540cdf936c10eda91c0b94e7983d880e01986f6531f4ca55effa928ef5ea2b9b4211c509aa7f8eb53658327cde9992f052c3a7aff2e2999eb45467b0446144f4eb595a90fec6576cd5f784e86c8675f84d3c485b726abeaba9f4c5db677d304a130ce9397217dc784310ba9b57c2666e72df2b0c5843d346f7d348ddf9db57083d961a9907ffe672e2857963c6f19c9074603cbd9af3b14eac9165beeceed5607278501c44be3b6af1342c899e2a24ee7d1b23e164ac5e22f2cc3ed4298bc5cb3a7bd1c935caa927a6d47f726cd73509bbe52171081a99f1636d2e1a2b4ad236ffb38bee41a3dd41b96cf6719e3bea49dbdb6528d673ee8ad40cef857b4b730c451b8149d3ed2caf94e6d1d49c4b79aec3872709ef7dbb92deec6bf3159375947b83b346f85d1ae717a9ae35c4bceac0df404b71f9d5d500ed193493f32a1a21ac4298e344333d7588f3568e161c2d23117423beef6954d6c67aa0a497335a851026cbd31105274567ee12fe2a8e942b8355eea7621858885b8487b9e1e0865444cdd2c787f53039bb3d3ebdc1b8ecac45b5cce008001ea23b6c8ba1cccfdf06cf7415494c97d6e18ba5e995215d15c8533aa9f9d5c9946d78f2593934a21852787a202d05a34cd3e72e537567620df9a60c417774d891a40a17bbbf474ff0ef965c85d18c2856fa4ee880d98dd5254649f87654abe923a550fd71c09f3541f0966e5b8c0563f3f1a1586a67633ae4adaa4a0772637117545aa270954afbe5250f63958328ebfde5fe3f0cfdf9ad4519f464f3114e4225e868431ba9da266b5d8bd6d467687a06070fb08f639beee7785b83e7f80489479426991c72feaca55a43114e47eb8e6fe6bc750a80cb937322a66d0f29cddd22b93b6f6f08efca5c2ed3612f015c45423d385fd12b507147394e749efe97cc7f163ab074399b9fc3a8579b4647b049dcb5872e217f93c80a9dc1dfff1511d7681714bfa15867b7b60f85a92da275ad1a642ea5acf8c25405215ccc8577bd866422b295339fc8439fd63cb028e847ef35d9c2d02532a95395cc6134e13171d18bbbe595823e04561bd7a676e298528f1e9880e087250d284b4987fe2178d154fae892e6ca648e9a0f92a282854fe78bc5488220e320b3e30bc42a0009f43a5d9dae0a8f5157b489d77033140c4ddb280926e5408d3e85414bbc626a8bcea6b741e978501e8936d7f45ae6f14f5c8419e1e585faa3d38b12db48ada25d74acd3cf8afc91be066ad40c72d28585243c29035c35b0b84bb9ae24a16a76c4705ce66fac795cc0a535917884fe5e279d8194a0e4676cf68e78107dda290de82edbe51892a3cc5dc7aa10ef40d8b7c808c432c7618df5b3c45bd4eb1a3df64ce8a2d6e52139a39856bb0abe544872a9fee7d1d365be3c703aaf4884284d8b6de2527da031c947cff1b2be40c0aa8c483f98feb49f3f742589ae954ac043b3964bdd445ea4f53f77e45fbe47802f78f7c1948b1951eb1f4c2ac4f66196b784b0fe143cf17c21d42a16b2156010716087c7779ff988d2ac866996e5ff8130243e395479a1964018e1cebc5e97280c73cb2a80e34ee984a4bef81572765a4ec10ec4d66133ac1502d0ae15e0d4c9c8c1ed0734b2f162aa3c5145ec6a02de202b65edc0d8996e239e4885dcdfcf1a92679db6e28a2553f6c253c01aa7e798f906291ba229014eda0c8c4d7d9719eee01647a786de25cf1f22eb67e27f48676770663923191aad3330726f1782edca0adf86d0d1bc2dd2ad3a8eae0578bfb5df90123f5a2cb1b849bdd88e5d22d033bb13de9e878008218e154774924b5aa968f91099e0bfa8e61cc294d6d46b72b358c3323733254c56aba9f4d872bcb1b3540930a6e6cd9251f9d3325d3bef9fced20db106dbf060d8733c801cd39d32044c444e1a2c6b200cabb833b53914dd1948ccbeec34962705d61face7e222130c4d5602eb07609a18b84ed1f8439d4611cdfec2101f4935bbd921867ba38bef73147ac7262bb140ed57f1f9d91cfccc15c1860d7e7783343eab76089997fb4e2dc11d8ed1022f5bcd09ded8bdd8d14b3908d29ec4550d2936823a347b24b00f29e29b18f52351f7a7966155a76f70d413c30995e7ef65e1dc456bdd9c9b707721bd2cd20c3915de0ec4ea9c04810240389cb816e3e8349a805d58b732c7a61029eaebf44002e6a3570c3de502ff6dbeb4a0da9d7e149575a998fc61a8d66beb931de5405da8396147dd20686ffdbf37412059fb5bd9a4bc843e030bd99e4faa9675dd3967e8cf9281f4b95c8314491da9bbfa7abf70ded3600b5cc6cba42088a26bc2c6c80c14194f970b94ac08d4fb09d424068a5f9d23a44ba0c9ba38b4983dd5e5e5b290362429dbc60144e1133c97e887becda7ee9736f03f74c94dcdebed7b6e0f10145dd44c609d95438c026d9940c25ce5f01e61e183ebe244aa57c2b064ea13ab4393ee660fa71144bcf703e66d70aca61ffe6037b2443d507621d1f3deaacf80272a5d2aa39fa1fbabf78515400d34cf69804e4fd06fc8c3ca1f48b83c473f02e1147ea83db6dbdf66f5de5ee588443a07e04adddc3d96d02d5280274481f4955bc200e742e9ed5068cebbce5f8029d01c1d908b88d9c68c875ad8c88bb1306031c623933ab7ff70faf3976042def395207049fd684aed48c28625be038a660fad4e71d3c77bb810542dc837eea8e3ed9cf5b18032f0c525f0ab136fdc152a058881380392467272ebc073848f805ca560b85c76e933c059d66f89bdb3f491cdb991b3ce42f8be59b6229b76c24ccc240571bc3225455a9f89faba1609f35362fd4b57d9172d606518a843977c6231558aba91dc497fbb44c77a3470673cd206572965993adc4d6da18f74e096fac8e1c658c53fb12b6131e8899233e3d390cf6a1e83be49132afdde8e3f6eebdb587b238122a4c6c14d3c42313b620b30efaf374d9e51d4592c31c7fe469acea45453f60e6d8f3887ac8830b66bb3b477821ed7cf8290cd9b665f674e6acdbf3b06c77dca20036265053a620a38b6eff83573c38adc9a9ba70cc236e818d5e87f5ae902aabf3e72589e3d7749d3eb5ed0e7cb7cd43e1b51b76144975248dcb82ea72a26ca7497d28a9e54565b2b8532d1320df3bf90dba74c43fdf11b881ab5b7c1fdd3a37f522bf550e2a05cb27c1f78f76158595ffa2e259bf1638a6ae4d55a80142e5021f690e351213d4bf51441c73f01ecd3101c3fc7290c65ebde43e6fe88658959ee4320c2d6c87729652c3cd9133f14e36ac78546cfa659de9db7df8edc144a88dc89c63657e23508695e1fbe36f0595cf6d371ae4f64346613460f0301793cfe24072cbd038afc170ee49be806fff21f4adde2625f13eddf8b19c759cb793c9adee54b48d2f410f14e652cae5425603753b9f10f41f1bf6493910727e3d633b2734d214869ac426d3d7171883ebdc74987739b18ea3b26588f87b1d05dceb1c99829b6b9e685c5759953a4650a53c4fb8c3083a81bb99f9fcd86588f6e1c730b1da200f4d6fa43c8b860318d4137df436dfc16e4d45a9e73baf0bee21c35f4d7f1a43bad14ead22bdd2e2f68668ca4b34b712517764318862accbe27074300b47bfe1f74ff15a51d1d10dd99e4a217e354bbe8e68b855ef6678aeed8d354eab9ed15929deeac4b23f51c4720fbc99f3f4bffdf0ca9959aefa32ec90ea8abc7c6c7b94895444e85109d0af0ba6a4deb891e41a2392e36747a6e6cf082fb8391e38ce867acab6a18324f34945e066c1946ad6e20983525b757415c658cf73adbbaa796183c35daab930d3ef4139cf68459166cd4a2bb3e2d47a23c0b63cbf305310f8ce3e38b5a49d8cc4658c64099e29068416ab9ad1e6085754451340f3247f55acd849350d814352dc849ac74afd001acfa45e582c2710373806eab8461d963b08344d5278d3498082e35a6df9e9b9c7dba9e221e2528a904298b4ffb21c918df2e6e88c494296320c189a0d6e891b3261e7228ef98a238742be3fc2429ef17c2cd012e49ecb2b02f2c35b16d111d2364c4054bd66bc8e523e865e5132aad4c952777547645e80fd0be126eeb5a9a03d62852e5e215e91ab50fa660111f5e294dfa689970107cfd29fc5d796026f048dbde813baba9dbf282f9365553a5c28f72cbf3c8bfde7e3e80c28ff5d36764f9dd6388db0354e86f75920030d451048f93de9e98996ce2c1a7118f7e31c0c7991abb876289ad68903293657d76d4e6b6c0bdca3723315645ad145aa2a06c4512124d49db874174c27b3ba506fa3f37bc887d54512fbaa6e9ddd61277305d1b1acf2e839bd3f15ed76f8f6e530f21ea891a015eac30603fd0c3c246499996802403d4bd508b458392c262d6bac461024be014039086b55a32589ed3af3304cd41878003d2b216b5798a66a43834798adfcb4f7d26e80aa75a91ea0b0a1577a699b225934945f72c3e8f255a256e5f9bf942a7a7dc17b0f4ccdf9d6d032ce1549bef649732a768b61c14cc8bfbb06ea8b0bbc52d1c0d41251b0f50a4c881de912fe28501b96a526f7ead4323e959f8809db4015598283ceee04d017ebbf0e7c3dd0bf0994f8bb22fef141c2b349af83d636bfb4e27c45b39156788fadb490035a0a34736b963dabf505093145d44cdfbc40b6bab3ab55a7014039be079561d06c4854922198655f0756ba918e23baa52f388d8e494a8b61ff4f95cfeea5ed5ac63d8456649798158f98238bbe3d5b4deea6c7e67189130f3c40b29fddf4f0bb24f3d643cc32f54d53cff38a7f91ca4f03f622fd02ae8b286ed16623082f7d3e145b7ac57da5793ed27267859a63ccfc83a884b7d9baa2cbfb3686373b56e34fd49b8b48022017e2f6839a5243bf866bc5fdd7257d9956fa3de649cab937d407e317887845f077b3bf3aa702ed4af9c84c46bdd61396db390df9ba4314dd0ff9db3db263d979e80951b35b92545012a799441e2a69b4a1f400683d43a89b7832e61d9d3d9b424db146bbfa2395457f7ef33fec86d6d4df58df49d4dcebdccb9f44a661b1e0030c761e3548fd17788f27cebbae3463b4b87e1965a3423c75990fe9021bc260cfab2436e96c6a6a3f7052f5369f32c59308839466c3c398e8d1102de1b8167c050a23241507cb6f4b50395bdf296e8aa37c8b1798472d039f04e0752deb34242ede0e8dd07cec7af3349e6b6c52132d8b3f2fbef70acda4e87c0ba9831cd8e9e75ceb4eb53d1f6d807adcb99126f7c56ca75343660b60f3024a16b1610aa3db17aad65446797c81bad6ab089a3a94f951772ef1edb9cb21638b95746232ea1bffe4d8a48660a3171f48f2495ebf8da7afa1a69402979b805bb6660f472aafb224d70d72424fda8be374db86159d48942bb80bc4e67b8e182f96e2bfdb41c41ab1d8e4805f7d49cd24f1512c83535c6fc3d4dd9b1264c69a70ea5fc213507dc2f73c10c6caaa59619ce9285dc6637715dce3dc7b1d8687de278129608f730a07b0a58042f8a4c156601f9624a7bd8f16cef679c08fd5b33458d39e5a6f1e40ae7d34c95a9edccf2633d564ded7ca1d08639267a892c11c9a01e180f9b04889e8a183900e59bffdfad3bf9278af597f52d9de0facf100e694940d1746ccacb62f23893d92c28f1d13104343ff2c6dc6ae889e87e1c1bbb65ca493311df12e7e279e2f005a4d00c171faa0c7ed6b1a9e79df32b034cbd8d15d3f87744cc9c3ece8b8f4ae89a8e025a15e3cf2d17a911b621e493e1d52c5ee51ea7cfd841df1a65456a815eeaf376e061dfdf1007ca9b52e3d64cd884e771bb2399fa833de932bf81d70d87d36d2ef68b0345556381f9f35e70ce0264c6ca790dc69e5a4c6cb25a537c2d3023ed019826f9f2d8f5fd1728d099d5c6369d171317dc80bdc6da3d7c24b9d8d0b16a0b6f9319908ca323ca7a0e48cf2e30ccaca4f0242fa3921141b9c83fd2b02db185b1a33efa2f99d543866348a13cca8100038703f28bcba6806f2669b92963d87f5817dad5724995ee0612db86c6fb12a9644328a20268d1cfc52a910996c00dd887a539fd67f5cd4f16215aea2cca4148aa85a4954390f109b1c79455ea1ec171f4b8061c08605dcb6f99f4f9548b794e0e183084c8e5330c","isRememberEnabled":true,"rememberDurationInDays":"1","staticryptSaltUniqueVariableName":"88a11a736a1bbb1575d6c91ec9b74c26"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
