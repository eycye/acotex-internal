<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: 416a85;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: 416a85;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: 416a74;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ACCESS" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d835a6e404de4253fbb88479250365fb7fd809241e31aea35fc5dc11c70ca0b2a9f5144482a92570f3e233c2969a3e0d3c523d925921ff9be8f19b2085a296971cc91748329b167e5aec99fdc03c8e9551919f454a2fc8ce77d9c215b745c6f457f076fb2f55e594e89daf5e45584404fb41990031f106264c32e7077c8d0aa3de8daa29920d4447e0a9d04030e70d517cc987c8c90e1d4adbc2e5f49fc6da61e749918046311d049039419c78e6f8fbe9426091d4871a6045710623ff6dcae028d61bcc0437a239bd487b39956e0ed51d1d4c2f3b7a49f47aa24f346f9bd6285c1002fdae43aba14ad433b0b442127ca2698d44f7f07fa13f60f5c6bbcca371724ba0e7dd26d1f614250142dd30310f7fb770eda24395ee28110682410687e5755cae0b3335b95a9f43e03a94fe33648b162080d2c18dc230c9eecd2f86aa2468ded55e16d63cfea13b15ecc84f09ff582958ad56c49959d0f4f9567df1c17af2603706a1c0cb1b89bd8d4bc793601481cf0a01d00c43ec1af81fecc6e58f38b5da8208602dd5eb4025f2145e6f63c666482f8b59e1fa24f2f256224b9ee06e79a9c341f26dea7d58c66fef0302a3c767953bb23ff07034eade3e4ab111aa3ab7ee35a0d0ee679f02a5b17740f0512d16f6cc837615f30d61f1d5b8a05cefa14737b9c72eab49ff5d4548ecccac194f8e9050416ffd5d03e5c3d9b8cddd813daaeb1ec98ae9e1ff0ae1b8ee2bf962d0288aa91006df394a48b70b125947eb3f382c54f6eb9228572d2d6ae45e0ae2467b195ee85671a38f9092bd5f7cb45055180452b497d3dd9b2f7800d2f9ce8cf30dcb47073fd945203dc5ab5464d63dcfec729e34cc5148c3453ded73e17daf873f44549faaea1b57c6c0150485f6aff6fb99d910115983f1ad4193f3c2561d5b1f79a42c81d085e0be7a88355e59a6a310c32d55239f713ef5b8ba57efa8f345ce6c5d58047057765752d23c12e1a2c0eb99479d9ecd6dd88462ca9550fd1d9b0e59aa2f0ff2ae51d840e3d6e9e9b0a23ecbb0c681a3efd7145ac97b2360fe440a71517fddbe5018702fc346cc32bcec18c0eea6587bc378bc9a75dcb50b780942ae95f09dfe221fb045fd28a71a2d9c18932bc28c36ca82cf85d0f6743826704b8911b07fb725fd216911b4dbbca8c6d879e8ce68a543814e3c860045c61cf195081924431340de0f8b2aa20517a701ac6fa95331d2168d0db6da24db95b6c557790bcc9786a459f4449275b315434d2e66b09d21ecc52477347dbf78332a7d2bfaf73cec34839760efc4566a0a4bc9e57f60759b0489d33b9de4b79ff95f1658b57ad342fed990541b9ce423a11fd2dc0904dffc2bd72f1f2271ce969fe8b852286f86f05882d8057b2f5d100c9133873bbbe00fe1ff40021383cd737e0f04542417a9af525dd123a5ce811621a74ef3b6f1acba4509e98597bd6ee0706eaf45cd046c59d2985b63960d39f8e73a61cbac6b42a6c4212ab7ed4c04cd02998da6c7ff8fa5564e485dcafb03f2704e244a86516e947c52af5d57b1646776ea71349defc81dc5b92fc8dd5bf553df85dd900db05d1d2b2b08916fabfa6cb4453a1b6f715a9ef4baf6324d55ced1abc1b9cb3845abaf19d56a74bb60c5c6e2ec5c94018d5178a96284c41be7435c99e1261e6e754eebe2af267ba46eb3c453d34e61a64f7b4f95aac0ed5b14e99b5a38a188806599969ed152ac8cfdb71d60f9b16a3c9c035a8abde8bb5829d0a1662ce8eabfdfb9c32038f087b67dfc01e720a15b85cd8102c8fa3784e111d521031dd6dbed76af1e49b358c7b7d536549a6b4886ac7fc53d1e90473a35cbd69b78a87c5c877349daedc8544397ee93f80286eb20cdd6ad81c0402d54376140d01ce83ae2d0d4d0b772e2c9b44808a5896de89128e8af79ebd3d0b54a18d288d6a1e2c740823df15bf7a070a58e8c2dd3ac44da54a496bb29e963bf1eb1af72125d38b4b14e5792c9c4aba899429ebac9908abf54265ceec22a6fcd612fba57cbeb0de400663d4e496ccba85770628dafe37bdefb3932681eb7d4d4efbf2ac8fa0add9751294e814c76eae1c6aa53f3a409fc124cd1333b272d820c5f3c8206212e4ea2672b26dd7da801757fc3c84f2aec43765bcdb6a77dfed5807ff5c7a80680f12837f3e5cbb2bbbc5bc3f37e1b0e644d7f34bb70df22b7901c27d54dfa96470f059d57b5eeb3c21afc054580fc67bbf61bafc0a0d057d742d9c0b58561c349466d6f185a8311f541ece820bb55f83b1e20a84a80e43ed07856866613ab858a34da9787611335a7a362e1909ed43bb29873a33dd1835520509eedd56c7c4f0ccd803333387183cd1f3d4892207788ad499dba33fb8bc931ff188e4b2d285209e5166df4493de0d53fc126fe1a3ae7170fcf3cdc5ae65408d0bd99030fa69af712237d6e8fabbfe166729d2e9568f81e61f3293e94724803c0a8f15619e69a3ecdf9ed3760e846ed60d104d47a2fdf8baf66d93f9096d5694ff8532ed24c5b9b593aa44dcc36a76cfa5de548bbcd6b40dcc2cd74af61b2a4e2a71d9532885bdae532a5f088646ea8addf8e3edf10f5d12848a4b4a391cc663e8e09af3495864307f0e5730b74f94ea9f76de8ac6dc3573c9c9d237c7c6f39536ed92fe977f366341e589e9fe35b7a473ccdd831a61f8760527b6253a67b7e75dc2a833bcede709573e48c5691cd2ec4834dad56060471ba14c89babf20b69ea72c604238bf430ea8bb78378cdc721c18fa51154175edca8b18f31b9e92aa3b6911433de7dffd09fdb146b64daf473a322088de19de84af2889b63070944193ee2afd8641c93671ffb315f357ed7c56d45218f9f93908e1c584f0ff12ada1c9ab02ee5d7a57f9eb9635dac2333daa2072055357501d242b903138a659edd5591c87b7473af5a2aad404825916bb9cec146bc1b7e59916e2b42c1f9e152840fcb3f6799f6cc6a09c3866d5c9433ce9cfc86c00480784a7b1156370c0cf2a73a7ccc06182f0c22b06629e4c724b9d8c756085c582520ca88d2e5fb8ddcbc0a20d39fa2107ddd74f3c88a3bb8e53c4c75a47e94b4b90e43c0dfa53bd5240fab6709b70763ed5b2c9c557e1cce9960fda49ca2dec4390b757334b4ed3494ba0c67c8519645f2e821033b55e5384d774478d4791a7a0f9aca03140c0b72ebf3597f118eb56dfacff6dd4e2899495d7e988b20bebf47ebe0f6a9519de999f1d8c6ed18caf094f2655aaad8036c0a27ad4a162666f686301a16aa5244cfcea0b57f2b81a94d5d1fa69a2cd221d5e5046240d02d3d78c5ebedcef0bbb1148bd7e6a3da66594d1f5f64c663ee0443be29015ce35749f5da014ae00dcfc802d940c62e407bd678c7f3997fcc54c8cdc7e6d70aea51e4544bdcc4d0bd82c0e5122a761eb5fd669d7024bb92af71cea099c2d84c96d2f8b1336faf1c185749072f8cb6d006f680b4c733ec66ae73f777c2b993f542acdae613a45bc5c91c3fa6642738366e899b9f8ca477ee47f27f9de253602f47d15c0f4d62152692a98a60bac4083628f56e2b07bf4c89666bb6c44f64e3ef358de6043d975fbae5f712109493d5dff8b7904d48066c147a8a5e7b268a5b0c2b5db6314e6329974c9e7a0c58dd9c288b56063004b04e728405f76ebd818bdbf68ed78e364a24ab7e59ec5a901066f065ca5e972e8bd2a9495284030e3fec8e729dc3a73550bc535d82da116969c58910990c32122152d08bc7e8202034f6d364581e6e8c3847afc93be5621a70df35f52477d846c8f7691341f31f9c8760337b4c63b257918085c31869eb2ab3a2a4fa04bafb89c2a91401efcb2d5d5500f25514e3003b94464bf78d92f7e31c623119cbfb18216bca7fad5f601c9801c09639083b6bead17e678c9693264636681904bfdca26870c8e709c98dd83a5f2d95c1080ecf2b902bd807e8c16b035d589be422630b299369c0ce46077dc4742e8eabbe8fad3885520bc34d332a7f13485fb7f9d1eab9f98ffac9b9ea7462955477632f9f2e18ea5afcbfdd6a2dcc72f398154d6c82c0d20d065b21d962e7589045401ab095662c740b1c982f939cb5993c150c31d3a53ef4dc926c8a7e5d26d4046a521636aafb33548d00ce36b62e24cdb1bae1a02f034692523348e884462258868c0a389ba755181a75cc6fba061627e40af413da814922d203169e614029072b2ad42be44c644565eeacc7ab530ec235f83f6ef12089fd962f6b89be8f5bb8e53ecac4892da3f098277272224a2e27bdb7e332ec9f5e6c4f74f40ea63c5106312faf5e57a45ddf6252c1352b57c22e815c25cd3054aa03882176fb00fda39112caf38a1b68de8ba8092dd447bba810ce752f5b30728183bfadefb19834ea9ab5483f9d71d31e8dec3edb878bb7e3a04151de621d8ce5c0e23df9ae1b1c57ac114fcb62000677a5e6ac443b220777faafbb0bd5e1ec012df9ffde7a3198691dee231a571eda5d833be15e408db9d5261be6f1679706d312194c74816d9dabf2e03195748794c051a5df3f34c727ddff01e633140b0139858f57defee3e967bc5508aab1207ce1ccf5dbc77346dcd57526ebc87b720efce0c024d818fbc852c2a11796073868d751376ce1442ba61b8cb86a76224db85f6d1e6e3c2765089ccde83fcd85349c0a0e93ebe4158117276113a76e36d0f8ef379ee962463251875a327a3fecb6e321672312fd300846b8bebf2c8fb733947b045568c0610196bdda106cf0d4cbb4d80baaaa62c301bffc226145bfe09d2f259caa3f31dfaf52b4882020927e48d3e796fa2bf6a8b7d3941ab32a5b3aac0104c1b2fea6c3dc0f8a8ce1a9f4229b28ed6a56365225f1868ac70386a0e2228127b667a9aff1f5db0660f603cbb24bf1e53b993a5747d72b26a9030a2d0915ed5267d6bd65111274b7695f5f8baaf85d17d31c8709f490c6960c59375bf6182fc8598e5e6e3ef52e34a58e3caa703fc0d306db2c70934070c5e45e36ba642b3ba210749d25433e191e1764a6c27041abd4a9be5aa4bc06d2a6554321a6e2bd40c747825113b19c001c779ed88457390a370f3d370e2c27683cd1272ad65ecb904a6085f2c041edbdefb35a1a296c8fbe4d090e233d95fbafa77d0ca5bb4c25bd7d14b1416a6ec8fef861ebc4307a522e14a2432f39d646d3e4c4163f88ee04e82291002ea9a695ebda0f90f1e4bdb0bd8aa6c3c534a7b561b5bb92617b93d2e770dea00ef9fb816c4b590ec7cac335d9f901b3b8df010a3e1c7b51022df1cbbc18ae17a7933a8637232d9634e6556f09fe07f56ef05fae7b7ad0cf795414549db3a00d79a13456729b8d56d00d4a3a8d753780ff6f3b7638b871004e43ca9a76f736cb84134e6203ae779c59236c4e311e13eeb104a6ae08035ca7717573dcc7dd657c30352d0f522f7833f361c4d51b1e7bb95552ddb81576d6dfd1f60a94c21d699c575f0bfa24cbe202a4a0f5f9230dc4e3df74596794d1203d27af61797d10b3cffe8c653c74f63393c533354eb13011d3af2a5aa4c53d3ec942bc290f5ec7170e3d09d3dc8b80d50fb5f48be3b67d9eb0cbcece6285b6dba6d5a23bcb201cc6489396a631daed7dff22e416832c35ffd84c2c43fbbb9428ad142714d76c0f612e5a6209987f4fe1f2af5e6cf6232197d55018f3b0e573bc97200b37d0842e6fb9577e9c28a20958253814afaf204e09707aae92ef1d2196379e53db4e43e1683c49df89b4d9d1c49d804d9efcb1996d371e6e225504677fd3251e6abbc19b3ea54b032719115140e155bfd2a704152a0fb8410914fe7894d89bb22441efa174926d689797ea3e4b3374a09d1330a2d8c2c55be9213d5a641a0f407c685532eafe9efb67702d0f6ad5edb778ba8a208e31629fe9a549e02b2dbcb745acc2b95a0d3a4ef14ee12b40262def3d36cf4db57ace4540dc35360ef26fab773ccef75a57c11eb23094001663e9d8068509171c15d7ce6e96bd6960d7223da109d45564a06ccc3c22c91f8b08e22e7075515fc0c462025424de0640f42ee65741238adf671dececd02b7c5d900c3a779371a34c3f99778a89d3500d742aece1cec6585df038e0613bd3d7722151e9c10b58ab37be4f3b03d82a1ea96dabe9fb444cdfff69f244d0eda7cc06d5c87a88a1a84ec6c5168882404517e0b2042a57ab88f806a4e1e32036fa019d3e9839c1f75d55d54973f6318dcafe290b022a057d8d439c01ceaf41c92eef9815ce01f06def1827ad5877cdbf975d4c330ef5da8928f614d17167523fa9c434e88373c7010f490095cdb78e2ddc94dd09cd48c09cc899185f4718b6c4a470f6212de3295733f1436419335e606c39306e6da9f21216f7b4a7cc330b5b27a22068fc04e77086d62785421379ee22d3f3c0d481969a3e4c3ab5f5004c68ca1301fb7fb6565cadac8d3370c2ee7117550e7fc35131f88fd6270288c0650daa471d3f7715deaa60d724aea8a249cbf2ddf57a7aad5cdbec477cb1a4328b1b680edff5e56a002862be8b488e09e846c95491d1229d735ca673e534fc911161f580a36fd849df2947d56e82d7c1e58b81a416cfbc5090d639de97c4a3278b045365a9864fa9f7d43e0f905326bf777d41a5b75e6746860abbbeef5e1c09fcd6d1b35a5ddda1d0f398685df4402b1360076a1b9f823a866caf8a65cac04d4d8684a88e96bf23292688558ff544f59d99a800bc503f317d799e4a017e55d2823b12f633207ad99c4257f31519caeb49eda247c4664a1c72f277d7fd98aa7d51f75506f2ce9745b159c61c746edbcb2ef9751b43744910952ae2da9daddc5a8c330665567e81a6b1206e2a8bdd2e51670cdee8b200c2b690e8dd16735f9f184ab0f023fb97798eb6b5a5ea1ad2002add235a4ffc28d096a5699e741ff939226ebb429fa813757ee3aec530219dae42082b1cf7f16bf3963c98131aa7ef6efc1c4c2e9477e90439f7b2739c6f4cb82a2ca08e16873de929bf6e19376cd8981e63da75633e440b0d2d43ed293ec2ce04076533385da64fc6d8af52afae1e814fa100d3caf81c7cda1d818b553568419301fe7312bd4b4cd5b7e83af15a71c63131131a4c46fa9375604444777638496dfe10239a9a198885dd135f7a23973520cba9815b9a45fd83493037607c2b227b05b605d6fcbe572629b2928fecd1f7843612fdb5a1d52fdb31eeff9c44bba5a39eaf64b26828c4b0c68151a3684d783909fc412324d7c1df4d36b7c977ffa163cc861a410cb87278f9f1c00ecb542c77d2a228b55330a34cd78031aebfb83a8211240e170148b5a91612b2f406cc740df732bc8d9317353675fe67f5b5d73fe0b93690f61239a867d5d768e08446ae9c74fc143a0f7aa24da17de00b3915bb4aa6c4e9a578563d508c5bf1d0f7c07dd1bcde92ee9fd29c7ed1ef6d4acfc165dfb0c9890b9d078f90065363166bb18d2cc8b7f90f9a977f6637fa1ff48c4c3bb141af385abe4c6312e980966617c870f67910abebd9affaccd6fed733ae7fc4461b25f4c46d393d31d1a384958d2146f312ee576d961d5b788550fd04ea1b20d44fcbfe4fa33ec739ee8a315cd65d1e3f7079ea616673ece10fecf4b344209a3e1965e6f7e77102661ee8df2124d51074fb86305e18205fe3e36d7988f8bf227d1a50692ee4e5e95e083898f89f9b7f413b46166725dfcc24f443c66447fb536df40f915559c58ff72be15fc1cc843059515d744eb3d0304d4f3ed9da0107b42e434d90c64e12b63d4c2e22e6a893f0fe99ea1afa1d994213cb2963bfe7f7aebd5fa2f376bc706452d72845a1874976940ced04ce2e08a4558bae4bf444c8c8f77da75badc380b8c924c311e6a98eb84511eb35cfe1d4447318f01acc40e16d8e82562470336f710b1a5d8fc56835978c7d7e1626c0c663911cd0c0d6f9d6885f0412777b00734630f902737cde98439984c873b3183ad004678e2204cfbc8ed41e3bb3f402292c9206243a4554122e8542f6a91418c3cc3e2c97ccaa3ac4a915db78cda82eb7493708e75e89c1b9bb281f63a848d0706c7c9e802d099835656739dbc297621e6d5a5fa4608d4220923c14a8706efb41743b17496516ff14af83a0669feb1aa3e1d7c9292a181c8fe36e21970ba050161dbf3984fd75e367e2c832a58c0bf362680720586d147995135a4c5ef6dc11648beebb586e5489ac57c4f9c44fd541147e55b0839285e388090d925450c36d0715ab2302e7ab94f1519407851b28583356b69e8da4aac905af16b5f084cc7d456177eae6db29eb2158922c2ff77dfdce796b8c989a322fe013b3a70c0532dc75de3ab9981f34456ef18e557c207a0d3cd85b296e6130c6bd6bf1ad36082b54a5347f83d816f66f82448c030f61a693c7942d771117608958cf0a15fce3b767bcc06191cdf53e4407e498bdaf75b9b1f64042eabc7ba88ddf0e61a896c0c8d29a03aa3aff1881b6bd2930d9e2e86ea04bd68c70f3c1db12344219261024178ddefd5405e3d765a5962d98aa69df3b0af7e8939ee176f9ca9dcd7b383ca2eaefba669178ce66949854c43e3277641ec8fad998ccf0dc42800c5141797d90ffafdbaac6fbef6edbc713caf2381b3f364f060572f7d6ab06746bf9ab33d39b64a5d4f255857c7b831cc0ea1e3924dc79bc96dbe5bfae0cfa049ce6f794eadda694ec74207c2eeafdf0bde0a6cc4925ebb6e8e38f59bbf5db3f426fb6f85803bff33ba44a4bdbc1a972744f3adc74f545c2ed1d52f2aac5048539161a46520d5bf85ff6dd51bbf363269da1f5981c62968069c0dbe25067231bb278b271750a5066f74c1735236a7085affaea892dde27afb23c2eede629e0ec769a299ccaf6596fec119a0ce77cdf2462a02465afbd3e7187cb5b9d9ebdb7ac913945e1c0ca3b2b2f15f09c574431a49a96fc24bc069ea1541dd21fa841519e1e81472af1bea3ab10b813f3bfa49c8429e67cabec921ae611de1e1e45ff133063d675","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"02d45590c5009dc8417b9957d3dfad72"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
