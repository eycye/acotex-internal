<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Internal Access</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #416a85;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #416a85;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #416a60;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Internal Access</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41435d0641709b6a7561526028e08ff8ea5cc7e989d2fdb90e2f0a4dfee661d5dca1cc448cb0c082f3c2834cb73441da08fc6225df2bd4991cfcc0dc6e9b758d7fc2f0ef81d1ef85f90c721aecdbdff5eba5cf839497b37c8b1a76f14b5ad86f2740132cc02a51431ff43c3b55e54fd4a28c31a8bfe7e8a78ff035ab2305521207797664bfe61285b807ad663e2fd3b8f36ba6f8fcb85e4040fa0a753e0877e1317d2cbb457bbfadcd582bb27f967ea02042a7ce9d412cb8592f133b37cac4d0f8bec22df6c212871b4c97c43ddadc28b2c1da29ffeab56bea3a2e8d2d5a114996d968b3ba998fcff75a7ed90a067e2350c3f57e3a8afdc9227f8cff913db41ed29437dcd9c08cbc82c780a933b7c0b323884e5c7a745771d75a902c08a102ee1a5ab5818841b31a45b018b3909a3db837c4d396c3efcbd73fe4511cd0fd1254d94c05d9589f2c04e7eed519778d3ddc07048a40878432edab47870a13b6f1365109a6eeaf274eb5fd65211dc3e164cc9bb501b1847f9c43f93b895fe658a926d22f48f07d7777ca69d0b9d96f7a3528d4b79ae3e95be8d1641390ae4780274dfa247603d61a91f9b71da14c2d63debbad84239950c0a0ee795497d407cac65ba68eb5c73519cdf4196fbb287176d0034cb6b0fe8d1ff8f5a50e8dd3834d5c48cc5e4adffcfba5e47b76baefd9c0e7022c83f8b9abeecee784194220ae199a9fa550bfc2b285e26e83cc22c28896caf967ecb74f758af8a568d9ddbf3ae6e6768088b6cabe0331162e0ac65a1e951102ae48bf9f5aa20b688e26724f3baf23ea6b05362a13de73edddc54b0538d6e80c3a462f2e2fa499f8a02a3e8b91d08f41c2130dfa5a15405b60c0af7c7858993bcff2fad3a3addc8d13a64ae8dfa2b1236a2349e9c29a43832103f98b2175ffa361b860a420fb405f923660f3c7bcec0f565bf443b9079e74a6349f5dbae1202461a938555fc91984398ecbd7d33d778343f96ac9923f41890960be87cbd84937fc3e823a3871bd6fddf230e359982a84051c291c7af0425f1476db7bde4e6dc3c099bd57a14b63c8454ecfab50160df1f17a0d6c50c6579ad154d1c9584c74a40a1d5abdd4da378f6126e9d50bdc3b03883d35a2cabf28318fdb7718fbba0fcfeb30147305f32d6d1f168fef3b26d2495c85dbb338b060f9c0a68db5b2893fb2a2556ba7591943666d16c18f183c0ece774e5644b1f722af3ffc482c396e45b7e446e06f43c7f1c01dcdd6226f321f60460ed6ebd63fba1bba3ca779dfa6f464086e25421840ec29bb4f0ed171ccf52686349dc0f3f50fcd35b85eab5d887aceb59b953177daae50d5d81079869493d30150cf00e19b64586317be12a840277deff6aafc568d778c2e5718503c327765d355bec1e304ff158c67caac15b648dabe50ba8cddafe0fb462660e0acc3db5287d97448d086c47deabe4dfdac791a2b508fb7d8860f5a1afcf23597e517ec14e1125372de055914518130a10b65e71f79d1089b3d4cb7a7035c70629f41cc2b117d96a4e356f7ad0110f930c9122f139e29febd1ce2b32d81fb865b5961353dc1d4cdad385f1f7a8e60e7107fdebd2ef7353e8e0ed6b8a617993d60d3dd053f895f205a5795d57e97ee1e0ed81e131f9c9eb8155bddce0dcdac6d8b4b217b07709cb1be5f17b264a9bfd5932da6ae64cb14aedb7598131d91128a0c570bc6db66fba032db5fba5b66409766bdc68ec9477555924c52ff7572d34cc0e948a917e56e6e98d63fc4fdcd188f30c18fe6e97c22789ee2256cb4e37ec4f82f2675c5dcbfd635630dac0a1323b935496567c659be1a94f86bc47d18fece273d0fce2c882af8373996d27d2b4386afb0e2bbbb00eb78fb8dc601645fdc2c8f4c6725a6bc4902ffa979adca38a169003eef38e45e606c01f9b96608893b88bebbbf101d20dd4c2927ceccee41eb3beabb82b3a02d5350414ca9927dea263755eec3005442f108a6bd358f58dd51022e7d1f354ffd21bd5328b635f12e2545f4866cf8544700967f134f9b2ac65cf54f99263b0071ea8462318bc444dc8791ed028c488cd58586662c4c05eee8d9474677f515090529681fc405fea35a3adba9a5680ca14582abc56aecaa6ce50e6dae233b57bb376df3425739f0c83b3862cf83b8717ede9b69704bbed40a31e57f98d03959a63725c85a3327c3921d00f2124e84928bab142aa9178f2c8e6fc6b621b028994b9d650cf32c0d64921a7edb02aa0d45adb18cf8439ded8f18d171eaeb017f8c31a307e6fe690d38815e76e412698026de662bdc3bfad743e5e8615f2cc69a7d8f5658e278a9d51b8f26f84d73c1a1e466d6aa10212a8006af0f64ce04e19aab84bb50dd51c61c5399b32519b8c9030b5cb9a9d0f977daacab87da05ac85148064563c0ffad428c19e53bf969c96e587eb46694473293b027d58addd28b9006da790b6138cba8f41e14417fbce50da851c26f8be818ed053c2e48ecd2f95542aeb61820952f7fbab126ce76312633527466bfe99000457c4f8597852eb83da2b16bfade762fccf6c5f61e7922985211f9bd68f10526138d9d7ec0218229df27dd4fb538b4e7638c49771c6853c8d5e08a18da4f5aac1e623c7a20929d65f398c6dcfa0704c59cbf84ee440c631689a78d00c8b08ac643a508f87fb3c32d2f14a118049cf7fc1b25324c5e1ef955f1c8455617f082a345e00ee2d16f0c664a2a7e04908e91d3a05c444a4f41bcaba4f79946b167c87a8e679a094c9c2dfc4d2b1973009abf1533e75ab8829bac14776088f4433a38b774e6d8afc3e9963d0daafb9d7aa7a9567e61ca4438cd25806de19e6f96db703be19bf368d5aab4e752ef49aac0ba7f5623fe385a4f2d1ab89d8bb372289254278b11bf7b2394e9414686e3ddbfbc237fb894ed31e60a62669873a071c10394e312b914cf8d4a8eb64802a48960e784c95f1ddc116a7596eb73b26a5c71834963db178b95cc8e2d03b6d390db5555bb5a3b09af59a1337537f011bdf2bc01428e2b54951050401ee0895a810a52be84a811112d6a80cd1ed33cfc77a63e6de8ecd178511a45526ef1e423218cf4a8af7516c0f3d4f37dfc49fb8ec57fc0256e119fe693cfab0a9446d0f7aa412df11a5c665049c00fb4ac23350cf21c4e428cfc68c575e61f7878b4de86f89b961488157e22d2a3c84be83fed3aa484025e34b12fe43f30d636030862f23b5623455dab0a603937344c42eb789df9f2b2642de2682b1609ce87c89533889a5e896357efd90e33e3b4031eb0e8af1c7042a9a25573956509a7133d1b0f9eee441d1386636d9c497dadda6ea513d3fd74e5d7536feb85169edf46c2f02b175fecfc662ca23dbf8793090313e328a3517337e12a3f9f6d81c17cbd0487ac870f2a4486716f7684027e68df6c0055cf9e25a895cebccb5c502d38fa78991d0f40a431b7d479f087029456e9e9b56e0488d75aed139da42dc0354ba0680aff1429b6d2a2f073f40b376f6764267b66175c695edd5cf489bed88756734f89431d03b4995cfa54c77183f43c3134eb5a39039ddde22a838f30f9448a5761a03a8c70a52565e9933b0cd77f79a18c76d3da4bfa5a933f67f37d47beb83f96fac732017de91772b77feadf991ca8718436b4f399025e46624b5bfc92e992c4e5a07c50acf4663ef429996b64a73e5e4a2d2914a1d42ab5e98500f8004456f949d2e546bdf8f90e157bc19a0ed60f530b98aae78d2cf72ee4d30d0d0f47e2545a629a7605f3683c2cae0ce471669f790b48f12893ab7123bf6c2f4e327790fa5d2f3e153851c23ea8c3f80fcbcf4053b3bbb10618f40206b0ef881b6d852e42707d3cc525e4bc44834cf0949d369e5d87a9914a27051a34776e6016ea73ddba4ca04dfaac69652d7622f9542709bcab8befcbe75f6657bcb6e525d231b8fe43eed4985db43e304f96aa1ac17693e714dd8810db24b929c4ad7798123fd375fca60b97dd2bff6feb282c2fb6743aaf74c6fe82ae5e4e100c0a938f2afb0f34ad5027cc38a8d4366c47937baf6c4017666f0da4d0d41d2e32b3165b6b2a0f7f6fa84037a2e93326a8a997b95fd0301c019223d73d495704bd897f1432b96c10732b7c9def7b7612dfebd7474da49c87dcc67733e11081e281d196d4f0bddf130947d229b4b7632db3dcb5f79e2dc425c3664b0d454599f8600cb17ecd81a876c51b1f94e1033a599e773630ff543d04ea34b591682fda8e98d1681fa6c71a8318938880128cc59ff966728debce62fcd618aecf27db475e005d992db24099f8822d1f34756c8a7b526e4f5ebcdbb13df222cdab294ab6410adf1d6395ddf5a06451dc9d60c6de37e870e3b07025ce48c3d3adbbc684f04c925864fa7e1ecc45de9ce91191721f2cc910ab67c8c1a0a58a981949b6b898dfe311ebe8d94318f27847e983d7592621ec037288697cda799de6933f6334c8a8baa07c79f8f4ccdede5c7eb14be012816658769af8e76701aebb98a03f6a094f14777c1ddc7fcf550f9eece72c4d49e1f43bc246213b4f457abc84db858aee7ec136bde5e4a9a8eb355683e3419478220fcd96e52c759d932f93c85cb8affc49f91e436069297153741c6230b5999694379b4cd550f2c1a62d2ead4e253ed1e671597cc18f8f307674ab88c4a9167b661651be69a702a40a4624161e84aa25cead7c2c6aa3c9d813035e46b83a6b922adee79271ddd5d1a2afcfc78f7d76b6777e90b6ae1ba2f4f346e3d4a890e74cfb05fbe831edd2e5078b4961acd0bc36b2768525ba0def9a7a9ee1566b40708eda022ae86a06affdcdd69f0fa434f06e513f92538cb0dc47b22d8f1e8947d1cd39b3c190dfc90f29d9ad177ad6ae43524a980c82692f9d7c0cb2cf028cfa6b841034211fbf699a50ea4350dd151c88a3c2e649472e053200b769eed5059bbe925de06efb34dbae89cfcbf8081d744eee6049e7b5d7a7d63362d68f1e13020ffd1d903dcca4546b6a7217cb4c62dbafff73361767551cb500ef7edb18b326f20a03be4bf9513cb83f3b00997cf82f2f4e441f518d725925a1223d1a21846db9f7567316ea779261dd41513d495e8a6a6791151261d4c1c1edb6dc9bd7dda50f32b885f18c99e4aea50dac8b297d2135a04c42c3bd5d3e90e8e45c1689b3252fc5ba709bf2a12f8b80b287ad8521e1fb81b3b7a944a8b72c96ba5328d26950429eb112853f6422c831d47fa323db62541efe00b3f6900a71877b49751ed76694e39402d95033b9dc0a23124be30802138aa4796fb5e3c56c92c627f51071780384bebb66d2121cb2a70a9ee169535cd8b5a75c0f6f6b823511fc0cf932c9b10a293168c323967bde3f129fa2e5325e688de04fc20f86a0799dfc5b8d1a81d114024b51ff086304f0572c3bddfe01a7d61bfd85070a770ea154015173a5ac59452b995105764102869044e566a78618a707d2b49768e26bf68b6ff3e3f2cdafa0e338f3dae19034ba17556bc3f7bf375742ee1c00f9cceb5c769694e09feb03d64c02a5fceb0f16b7305d5075dd8c0a8bded03b45c9403dc821dd6146a307c01790bda584faa24c7ba2ef79ac5391186a7e9921b777adbe0f0ac47140b71a498a14997640748c94b06bd5c7323b0e4ba305656934a1b57c798fee3c061564fb660b3d512f0ff57ad1134d5baec31ad7b929de9a6341e1d97c0e5acc47a4ca71b08001abc786a89a615649be84934ac91f74492ef67c7f55c6f86cfe4f87d31bb1953d6732f74eb1a551ebcfd793eecbd4dfc8b7642f8a88cc641f3bdd6b3870072e6d19679aa621ba8ed86b7e35e3dbe10b8402c32e54087276e700c9705984129717a030e0e65931db3b4dfa089cb8c83112688d1a05f4ddea61d3f751dbc75ca5214121a475ae4254a5d80f01b56d10a14cd69d614c572e1d0e4a6f2089e9f352bbe44d1b9c9b8571c4c669f7fa6a631d8f9fb8ed0ec607cf16ffd6944fbbdf79db78012854e3b96e2cd73f71cfad52d66419f0a3e305d7094cbfa796bbfc2158f5d2373e21f48c8b0567409eaa24c4945c940a83708935e935372613774f739633d44ce1c4a2c51980fd187d2567f0980f5d3ff516d938fde807c7d7e51c4dcd3d248e0eedb086034cc58b333a51bca924b6d9cf4d9d3fc848aebfc278569dc3fe3b593bc2261e0a90f4a4edaa0517f9e4c51e62b2eb9ec5aae6dbfc67e8409f0940793ee9b6a649c95bb30117f54425c8fcb0cc1052b47b37605f5bfd86dfceb2626032dba2eeadbaace6cdc921b206d6c6563c2681a57e83f047922d7174e84d8466b1aca00c95143055973573b2dc86ec268a32157c475883a27f54e0c1e24e4b8bdbd17f4614711f6050a66ccfa961c0bdcb1b7d3b52c0526309339baa4cc5cc5ec325c9adae68a8669089e6329ef46aa280b9f120e03293f3aa567ff92731a10d69b374b6458095176ac8d4a985af37ac58cc9f159ab0af7378df981966285efb742ffb233e2a296afa7f056324f3be148462d2e8acaf8fe4f3230846e5e4958101ab80d48e4d6457e9d47b5f6f604db573d6a6763cfcb9aa880a7a34994a4e605c3ed175fbef2da5206b69101dc3c971cc94d8f81fa70b12619daa600e3a69724e0d82ea16a9f93ca8897d4e60958826a8af39eaed135057fcf1fd9adab69f4d1e17a73e8dc05d074d00a1c519f64180e18be6e639677522dce3f6ad5f00c09aeb51785626a05fae61d2b1eb824222747d261fdd8ea70e7c995a5ab75c683acdc91e20d4e957e6f388f3ea7c44760796cf05030b5ef8484dfd80587eb2594c825d6bf8a056d1a7afc84c13c4d96297a710430f2481196717e746e22d85b3b509a6a38d41f6b68fffee8851da6abfe1990a1e2eb9fda05eb5e5e643e29777acc3a8f62c62eb1f44f45dc3f09e3d6d33f19dfb23d382a721a4da69818ab2716c7ace3318ef706820aada24fc6fe017f59bbad1f751c16bb9c2fd0fefeb1d2ed1bb69e6b51fac3fc0475cc349d43ae037f88bfd024499d0b3481a2ceb496c77b1af7d34d7136f09f15ba97db316600ce72e3d740559df96430cde897b08f0cdc16a3199be7577b7b5420ef150b71f2d25b807b705c1f45ad802467597063faee38b4e9be94aba5ffc19030467f97fb627a54fbfd95dc62857076fe2566c2d35688c997aa4709cf75ff552ec938dd922765523d4e9ebbfb1bf40c5bc41abb34c5e51305958173d6556920a0602e3822502a5d9e1c8f8d0be072c105983972ec0a3500636ae0f9609fac251cbd47dd65dd89d640338e2dde027cc227fd91e28a10be20db3a657d23ecdf75fce44e91c4994c3d1078cc33b61a24552e67dca561ebc9706342c967657f8784c6023eab7163e6ff1d86e790914cdecdc146eca74766e00957bd89f43675220d4950721b760bb06fac9797827c8b6b6dc92c43e87d72232e4d66ae0f35b65fbba4fe3a721eeb49bd146a1247863cc4f55a46321aafd1e789e27a17403d4b736a8eed28d090116aa328c7c99d44e496b69d734672caca420304081fa6a3f0f75c0d915944e938ae3eed4ae50f082f36655fbb1905567bae21b347a8bc0d3f22ed0a28fdfeab685348181bbbaa1d526f9637ba3f330e20d206e7b6b20583230bc3f4730fef790d17fc56cc34dd62d8bc9a66029bffdf11fbfd7a532b72b27f873642c369baa9b5ab131e3df03b800fbe61505df3a45a367695d4b05f5c7ae2ace97a8da2d4a2522161c0e7c70e1888c3123ce48bac107d015650d9de206e6ca722d269849b7708334eda0d031cbef28389203112c68ba7f6cebba448775ff8e8aac8d224e0f09e5a47ba087a85c0d7896189899cb3a79f0de2d3dab3dab3db1504d23d2c214c9e6f71e5549b1c077f16a58042e8bf6951b6c6e93682a03425d584812422d30e45dbbf5c5e58cc12b2af12a798109a68802e7366186304880260170576ca3d931388efe1fd901870522ebd1ddbb1a3d181fc71a2bbdcd27e9bf05321a7d276a6f2ede7354943cb6e631dbd66c65a49bdffbd16be68036518e3f0ce666c18d8619e7ac0883387d83704655ddb41130c1a5d001cce4f8e4e9cdcd3a06c66c0466b15be3832be3123b1607e923a15e500c96a1f65b2b315d7645ec4aed670c4ddb35dc42fe93521a5ddd4c33315746524c0337a26dd0212ef122ee8b38988335278199792639d816ccaa56ce1e95583977bc4074b52997b601bdbe35168244399f3e66e941f5cd3655fa75084839d96b625bf29344aa20621565b2057efff1db5e4f819ebcb78756fe557b2a9cd27b0c782cff4a60716177b4d5a4a6551d575997099e77ddce820b0e01b5d8af41c7df78c1c5690992281f318567248cdf542fc0069f296fe0c64059c1ba52abbcf7ace6308fdc299e124fc50bd47a31d42bccf0ff4965e8e78b5c29b86e3fa7fe9a862e78f0d76f106ac42fdfffa7a8f09ad719da3ab518508482de419da46659866bc47750d3ffdbc2db74d885df1066db432974d3df511e3c22925f5ae8d86a2aa15fde4d70d67b17b0457d906b651c5a462444f1c2b464e9ca49a92938ed0f5311144f89cabf021a3487cefbe24e0fa1068bd5aa75e670b54a22991c9482da48329e64f9123b31edb69015c3359decf4326c1206a019cb0583c0c25dc78726f52fc966d8774a258d0b87e68179896ce807fce62f4638b93f1797687cff5f2e2a722879723717876d42c046dc3c9553553be10cf09458cc8c1ccdc13bb3df18eacdb403a896f8b303bece5ac6a871fc540adfaefae502008d7eff100b705af2d688d07afa71b0d831648772d04a84d4c6b0bb2e02291d0bfbe1f455a2cd7daed64aaa13cc19d95f8e50ba73396f2194ba786334890c7f26b2dddc8a72d599d7a6996812d8f610fc08b357df71a8bc92fdcb6da6596b48d091ca9fc3a47abc67caa274a1836ad744bc20c0c48f12a1e583aa087225ae7c5809f90e3dde687b460399d6e90f391e6645dbd1689a6d5ef2eeb70d01a4b463ec53ea05c4a9f711277760e84d38a5cebdbe02646e40a1d448b80777cbefc54b396858da304071151fcb2e5f7b59b595c997bf113d955d6d9f3160f2246205c885b4cdcab60877a597c86d20384be556359b6e2dba1c32f66b1e4e9de05489023ee466bd4b2c64aa13d617013bb0f918aea12a091d2bd923dd51faff2ff252f7dc71205bfbdff09684a6c6f3a0473de65d1fcf71187c41a747856cd406960a70be62f96561e9ff481e20016c4f425e431de8ddb18a16a51a9b2c114011583db69f9f31823c02418bd05bbb1685658a7f16ee9d3e9b64acd64c5ac90e432c035c42b7e8c54eef47a07976def376e8385570f8e40de565b7ba13def887345653d64542193b1590b0792b0b800819de1344d67fcb782ddea121145e65ff86bd0c9c08d650299a811723dc42025780201e985e8c9b3d24e6e563066d178597bdfd3e1eaae2a897e0b727f036f06108fb58235799087c59916984aa63b65c89b0e9dbb856372f2833cc0a79617514234a00288eb87814adceb681861aea85ef553b9dd1092b555fb3e1748ec53e9cf93111a9bf0eeab8cfdfaeaeccf0d29bff6b88f2eb65c01ea7006fa6425aa7fcd9ca1631c94dcebcbc0d7dd68406eecf78eb9f58cae85014e852b9158e04c8a5a7bacc16f18eda6899b162482ac5c1fc89c0639897fbd118b8d835226143a21dcee0e1606b16cafefa5862b4b3bea7ebc4c1a700c5383fc668741a55954736d521d559f640fbab51df165beb5331ffefe9491a4efbaf9a03ff4d7299b22c06cc2f43ec87f8ad6e6ebd76b9a16d409f20ec6cad69dfaf5b3f948f90be181181928b94154d77932a9fda638982bd444f695093aaae495e094c60e6b91b15b7852c5768f40a3ec7e1accf64366f761a53ef705617e269adf1c2c99d2809f6bd229b5f841cfdf54470c3d041c2217669408e14a6eab023bbe7b2c6af0e8e07eda837d31c88e26e9444c8f9b70518a1dcd58c2ecd796317debdadeace1558a386a8158e767ffba711607a31f093972450002f17ef4c58af199a19ec8d46c167044d45b6ceca045a20716227dcbac53a2f1cd67dd1323153be1a4f7f08e95af3ef092d519423d9f8571f580f6b8ff4d17c591a36560c91a14fc6a90bf5d2db89e6d6164c4c7d48c7a4036dbb0697228826365cee1d96fa8621af91b2c876398c915","isRememberEnabled":true,"rememberDurationInDays":"1","staticryptSaltUniqueVariableName":"1201f8fa36dd40f45390bc4cd4ace73a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
