<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aaabe823c1c460745218a0f13cc5ea5d4bdb8b5e0544ec1a662e9ea02773fba0eee477ff637cc2fb32ded6b0c3a0054f2391cfef7542a56fd063000302f8b55d44d2aa44534cb41e790aec3637c2fe77efb32a036135f5098c92f3b9945e4b4e378cf121431178c6506dc5631914c5e1a43f349725a49582e32d34b86efb116d6b3437655ca5d78b726e264d745e543423f59c5dcc34b1086a846925ad72d04116060896ca6d70e8014be4b549bbc4d6124700161c8c35e79818e62974ed5d9eb43d1a34bfb05a7786de733207bf0013229d9026386dee0f8a3adb3d1929537f4a6b815c1dc5825bbdb9ef73672628d29251a74acd01c5f15d8b5a3b212f5c6c179a58a74dad464022323f55ddeb578024c15bd89371795912c1b4c5127d8771719aa4e2b1b807b70611f1c6d7d7d540a10d1831d503f9af8e184ee9270851b528dc5d9691a5a754b6de5301be72186e684cc6dce0c880bd7ca5fc094b4428fc6fd50b4f3f051767b51aa4bd02516496101e364b82bea05651823288adaf009bd52079de60d040779f9c0929edce3815faf26c0089cc4e759a8fba16958db96f542a593b773a4e0ff42b86f7b6f13b7ec814619ff29baf6273e7b16fc8a1b75d18b3b64b96769877b16454b817d8b193183161eca610e6709786b739b5a297c16593f819ed5417d51d8bf2ac483b4233ca6f70f13f755d5a5504fc88e7d9ba622e28ae3e01e309a7e30aa3f9b11c9177f2425b1dfa3c6238efeb04435324f98c95707d24bf9491c8242f22af79d31d6cba1dd369c92d407ae95b7dc013acbb9f73e2401bbf16c73f33afc1ed8d14b0fb4e20149892f1e677a2844506b3a747ce83c6aba3850e3fd5db5509543b18dad719d900c5218e9ab479bf54318cdfce33cceba3d40e136c6fc834e01db64e7bb75a9200946cd51b28f4f7806eca2488b2c3b33ca4c57c7965a5ae32243a61986d2c43c088daf1c655dc8e626f3b0425bbdb4d8d59e32ec3601d58c021e3479fc63b3a2d7e8f196a3df48672f3e3888d77805a308d72efa5442720316ca2270ad56766b23e229a56ca3c4461dece6784a25ab258eb9a3572af82bc31721de15c4e2ed6c68d44f2a6f58cdeea7485dc1f199079a16ecbc0addc5fd6bfe0f6b053ce76b0d3223a919cbbc5f62e62bd0517aba3043affc3c371e72a52c59efd082274c433ef2bc0c3f8a0a1b4f034c238baceb15ded0702995a93f26e729d87b5c2aa38a45b81e8e4385aea366fc042d9448b0acdf83c4118632b21eb9b26885ecdac4916038d20686b29bd37369839f61ad873c4d02d7e1f1d0c3a27e14eab81938343e3a754a32667ab0521708a8942029d1f14c318a33749d22d05b16c85549e3f2af3409c3132420f81949ae4fbf7a235977fc848f7fd4581d445ac6a1f0eee889f44154dab71e3de36959d5f15b26900005db191c4add8ede456724fc2d4fa1388d3e05cce5a46ca4790f900767a4e8f82c751141f21a46190f2c27ca97ff1bb067d2f63e5ee3135f806e1519bb51fc4e29da90c9c3a64d018d15b8d6ebda7c9551a0566489ee3cbf06842cb691c5db66a2868468dcbe686b34f7db555be082c9b9da74bc3c64f549cff28206390b3b45c8605502e408ea684474715eed505eb44c284053bd191beaceac6263edc248946c14ff4e8f66b5f2964bf95d9eab07e8ce473e9b74e734e781694e7d84923d6d240d851d313df5839cfc231d1f6512a1278e907f06ada4039c887ffb7f00eb7c09e4b57cb2f2754cefad1200b95f55077371b3d2ae88b6be57357e8c82be0a0bc46cd43fd3319376452f3113f9b7f2ff3310fed36b4cf09c0861438716a7038d214793c51ac4679ad05201a62b023b8ff8534795429beb5ee1630b6ac0e0dbefb8ecc584179adefb5a8256c67855927620207ee2cc998368b006b8a02e8f39a6e6f4c211cd181fbe803cf80aa74b1f7af5e849bc0f1f8c0cd57fa2d58d067dbb78cfa16a78e4b6deffa1a644b8f6964e51c162af98073463b870515be002845f5c10439e31248a29fa1b28c248b560330d8dc29276ad5faf543252175e95be47d141207f3cc555a98bbc7dcdd510dc9abb723defcb028e0d1520f19338e882ae6790f0684170c54da219af2d27628e8e487f383b78d09f3ebffc8c77cdf5404ffe2ef72e0ab94ba8b33ed7036f083d9f515f54b86c90ce5f287203660891bd09f27e19d522e0cb5c3227d02c2f773e576a1bdf4796b7c8a90da0b27464bf80d042fea9d3736ea99c37d9e7a61b278a8ceeea75298cc9c6d3bbad001953c52664fad9cd3dde412c719beb751d21e69468c689dad91ac0e845972097778ad3269d1e8555e04e7d414c834a1c3161bc4222fe3313da6840280cdf124fac594d5bb84c69002f81c02c62866a1749033bed2c8986b689a13a05de339f6da0d0ce050ef9b255c035454bdf6b9454b0ca2acec9ab464ca5f1a7d4bcc0f9f0f121ef01711c4bf4945812a384f807f00048e9add9d5f01e42c1eedefc47bbc17664378a850200d620af012c96d51942d8a19d1cc83d6b5a6efe51a880c57932a1f57b05192cc752c100ee7e9c392cbb058754f8307ca091adacd6be6be058aa81d8ac1a36ed8095f0089e9ae8330370adc7726d176822e671068f469aa97fd0fc44f9d4c24ea7345e84da5c17044651ec112a38ec933ca29c797e10794b8400b113f0958129ec0d603251652de6e831243dca622dca530169a6122c46e4d27d32e4f3dd5d571064421a535b11bd88b53c887732bc8b2b2660a89e2b7cf05ed10a4acba472c10f4302c222f05b62501111783d6094f820e182fb32db58ce11aefb413539d8ce9afaef2e714a07fd992a807779296ee977bbaa0132211e66d2778be40bab78f3e8d7a7696ac072ae1622524526c77deb7c929217833f8f5eb66ad509bb44fd037a59b61e380a6e9d6329fa98224d551393f3aebf85ad5c8df20e2b1d47897a2b1ce8a9e48449dcd15787ef98e2d1dd36cf60fb3b219bfbd160bfe10f01b1e8275287b3952bed9f1e8b5139463ed5a425e5cba680a90b5aa7b1a3b68a2320adb45ba70d263df641b2b05f4d0dc85cdbecb1fe6e1fc114256183f2b9163edb203b355d2f119899a61424307d730fe7a0cbb2346c001a2c6e9534f0649fb869fe5c5a059052d56f56073aee645eb626caa0adf471bf4fc04f23a6ed82da27ee0089ef7e4a63cbe13257ab6a7807d1d1970d67ed30c2948caa298765377d3102107b2cdbaf88bb4d4c9fa68cedf4e8a6cec16a239acc35281e64f0ff8661341e303e0247c1e2a3ae9e6048fca883c34e9f8593c00da5d03e6c54bdec1b5767c002e05d99c773030697640a9a5b088b911f7676feef249f0d6fb790954c594ffb1c81be31004201ac659e8016e518fd8795999be7ae0f17023c1f13c913b28897c49baeab0ca805d618564db317c3c18943879a57d588ecdc3fe1084be4848db1674632565a20437bf3d48cca4d7df232a2321de329c6ae78929cea454ae8a0e4bf630fa7c20fc3177480610744aa130f3998d9861e2f0442202068de4c398448e67815ec10d0645d1cd5794b5c0c6aa3cc4078e8851abc5b3f046cd010e5e793fd36de8ce98afbc62acd291be41cf26c34be66d0a1795e4775822855f103eee05c9cfad624838851cd9aa19c93d8fc13eaa6ac5f7653889d18d02f003c54a8410fa9127d3b19845775c6f1c736e91be1ae42262670e4b52b9abf30a7e5ccc84d261a1733fde27a6c1e349235b000efba671312732fb90246142e8ab1012e9e6a6831c9f83c878633e289b52ec5b5db100d9a9ff1e2526b73870235dc1499b8e14019dce62446226b43e97b9be4bd8046ad22edd42c15706afec1119843c6bfc28c46d6323397d7174c0f9db80c5699efb97f8c9797bff9b3639ebdb40707933e21d669679b591f4db8bd010973204b4ee097d0be247a672d9fb5829bc90649ab22e10f36400d37ffb3930b9a3cca72a95183497082f27cd5d64b74930d312afa516039a73bb9558e0e36dcfe07e71bd6677f03f29a6bf1f2974fa5d8b08e0c677599c98eafffcbb400c3d947ebd1d701c08191f695be27673e733cfbeeaa2b7bc6a91b1592282875e264704b8fa72b8eaf0b5667f770d80de6159deaabc94582cb209d130eda4679263a4d6bc5821275e6b24bcbb21f5ceff3fbdb0f3d38dd0b12d417309358eeabe161db1a7be0fa95b59475351dde4923d995956824d4d8f850a2eb9019595ce22b86b00122347f52b6bc65f450a15c988b490ad44d4847c499bc0f5ac496e602d612678785f3e4deec9a63043cb85763508b3d0ebed9394b6ce1a2a43b887b45c7819b11f8b3b55a9f232ba1d90a057e4f061c90073d4476615078c21fac31a3c2078f7baf053e5cd21d2aa588e92ce26597a6ff3530f364aaa5cb506402efdfca7ddbc46958995b2e14725bf35eb55780d135e30464439466d53a7c10d4da82f62ef849ccb54428c8a1f0388ed3f6e665083848f0602e0757157e997d67ce41626bb7d5f116b1d9e011e0218731de3e2052371648862b42a3aaf223f497abfa6fe2402bf126a526a064399d7712fcfd82225b0359174d6b7ca5f940d45c60c3dae8f1b9b305e27431272aebd0ff82dc227d730016d9a118e6508fe4bcc66d8c323b620df645998c9c14db083fb5f8076d31b9e2bf89fa45230f81170297ab4dff81740422c5a0b33422e654bc1fc315d90ba138d7236338328b55c2e8d1d2b659d371c5e1bddb329abbefeff84e6f8d61cdc5f228f22d97548a654192a16a36a402ab1be8e9ff93d3b93a42ec6832365c65ef4149343016a6f030704c10ab2aebb8b7392a1ca943d89e29dc998f072be1188328ea7723f7c7040f28b013993844958004fc4b594c890f200f28743e2e5492bde0d85f89160be82afb76f5857777b85a7d1d145880797e162bc456aff0227546edecd59fb4c752482ba5d34b32c25b6ead59c8d479dca436e1260b3ec0b867d1a110ab71a84b2b76703a3d17ae91feadaf2f7aad95a2513b12a1a586562e791e0db97f94213f4d813a56c63b41792ef8b124ce2ed535d112b4c82b2cf72ec8487ed4405215febc57d82f9b470163286b68415d94086ca0452a2a237676e7733e3802ae4ed62b5b497e6a335a1c988ea5d4ef3cc26f8e57dea862e16011dfd92202ca815ace3ff1498c8988d8ac6f4a0e66e734c8d7d80486fd6084bf2fa22d5f38c0a65dc0772af6acd513096a4412082cd4a3ae38486f3602b9390db00e037d046154b4e214cf354ffb4d9ca068e77db1b91864146c787916b299051453eb2f65d2e80982544b5d508f54f5ca35dfffb3342619271cf3a75d215b42395b81ba84de52a78b34591372a1bd7176f15689e4466591558f4c64381efe0e032b4566fb62e930310316d5612f1973108aec0f13dfb298a806375adad2dd398425b518da6c0b1de496e882f3eb0877e37c314656d4987e8b2bcf90afdb929ab5d4c63e208a375636d7ddc07d8289bc7676626ea4b1b2e420d2323720820f06c02fb3fea22b487a4a30a0d8587587d32fe140a38fde2e040a1f8b9caa6a03bb34bf5f7422b1e206e917b1e25a8650680b461bb3465bb7c81c6d86b855b4a07a69bef7a83f40d3d9a9c6e3b01e364faa52286044373d13ef6dcca5ff9f723e1726fb5551cb89e9a37efecfc4b97273e185d6376017843a7cd0474d68cd6a26727204a032e5d0cc428d559e10d0ae0c742ce0e16c2c4e7df0627b652fb26e1269e183fbb1b129c403752667d8811d1e89bfaea57a2a6a55ccffbde2122377bc3ffd144960889b82513a080f4ff25a261ab5374eda045ac4bd8268961210ed0c95f91de933e17deef7ad015c9736602853e289a600dd7fff2ee8330f8d75605c2799dd026af7f665ddc6e935f96bccd352f5c80e165416469362e88c1d771af53d4a66acf246d837d076685af1e595c0a5d442d8b60b6b0420a2edf54ada468523a69c296dd60889ef25f9911e32a931e91a7cb5fdb315e6664136d71a0cbaa4f1208ddbfb729f8a03869a2b2d6a304fd93727bfab71fe3fd2292f8625d63430c232ad81c7fd6eadfb48d0bf6733c3df6e3765bcb9edb12885a85a7139acf5ce15f53e7b83d1937a9f2436db622084b12592f881c8a2d0dad86f461ed8fbff1c1a283aeb951b7eb8a585f95f4ff99b94b54615a11f93432c487c82046b708544730ecc8866ff0e526c91375f0a22e7aeafff99b776b10b2044d6b33844d8e2410f907d7ce8edc797a55032890ca4af67737db5c751cd6ad2db34e00b3eca25ec3e1161178840e22dc3ab99a829d31aeaba952f8ed07f410c76d088e1efe4cec05a68ae62754597bc04d7e1845d58b7819c2188f2f9815b2207388faf6871d0f9cfb6035b268cd42f8248502a507bf629a8f2eb69ee78fb9ac54de38479e5e2d549f2515d9eee4fe88b7f2e37fd0d84e6a78c61432dde75d2b070964660bb146644d9f6b75672bc3060d22f49520b2cd351292f00f198ec224c9af447d357018489c1fe6ff5544af2807ad87fe273907094d28bab03e4c35661b81df0cfaf041172e9e0608ffc2957c44825efaeade774bb6aa90b27805a65d48065bc995facf77cbf5cde0af67719504c52171e102e99e0cdc309ac310600e036caef8cf70ed2bc685b0460bc2d132b046bd11a4ff202e86d1cf33c72958b0dca0a2679c9cdd05b3ffaac7e6896e9a051cc1b66d59f2c3b26b423b39f375e459df0093988e40ddbf962b48f908be7bfb101b0a76d13619e8fcac69e24ac8b0b58b6cfc30358f1d972c2992944bbfd6b2a1d0c29738a334e98dcec57bd291159193c7a4c45aef89887dc947d83ef8ec2fb1571fc44d0b411fbd5431dc3a284c42d6f0704725af10bb2a98bec54f345e60c6bab934b44ebcd659d2a2300eb6081fe501fff54076667d1cd67f93a1da8e34710e48d894c3f043a0124c738677d143d796a45bb3f7540866199b0a7160214ca9d75dd25edc4417b5d8fa38af82e40c844734882c23520e434a235fb9ee1da25ca28dfba2f93298b780b0725ed0306e5b56f2651904901d11f53053216cb1e9e7ff353d469b4e0399cb0cf619d170e572b4ae88c32dbd9afed1d95a26a2152fbc15b58d4cb38016243dde7d8fcdc8f66f0e61c05739def317a06d628573bdbfb1f8254cad3dc8aeccc97a68aa4999523193ad3fb283346151264419f9fdd84f54c1cb51dfb49e4f3ad8c5d9ab28b3a21003465ef3cc89a6842173a67fd8fcb74ea460562a6d8bb86eb730d859efd86cac9585bb0a18f70f98ea48e8c7a06deadf7a4673e735ef37314da2f72e470e0ec2b4d3cbe82f5059600fc1659de8e691a346d01c7ce51651182f86374b31c4c0894463e439180a3c62ec4309430baa2946880b8c39c2304a4981b696369073dad9285d3113a907f9c97b1197cda09ede70998bda77b748ca4702e03b1b93bf51c607dd42e0e1d1980aef82cc50b6873c881ac21a64923e5b9c183849f7cfd04056e79ddb9155226fe5b37cbc9fc6cffdc35ad7377a8b0fc777ace454b64a3c5bc64f637a399f6bd9177a72dd22c4fe69a638e1c4105154db21a3cf7b668393c7cc551866a4917fa0e7a611a354ededdd0eaa57ab9da43cbf502baf8599d758f9b9baf0b53a25ce3e3928513ba96a749f90fbe5695cdfdb3ab9cf75f50b334612288df8dcf5daad56576fb58942349385be4781a155fa7ab72e62f17f6dcc63f83ea97fd992988400002deab62d01723290c13c9efd10aaddc8c5175909e5a82ee9f06f8737540e1ba7f7a21acea27229b59996ff12f418456c8a0cae9c80cf52b1cab42e1d37d096450f77a18f9d572bbaa48776b6221f4a5bbb99557769d280491e42923daaa1e8c5091093087012115fb2b359b9836e024fb7d86a14310c51aef661f14ec08dcca66f9ec6b316ef330c7603b60dc665016acb42319492e664e722ef776e463712a892224db5c9173ef7311ef17a6d75a9bd5a85fbfbac7abeec8c20b125266dd780ccb4aa4df87d07cff45b4ddb39024016d87d7e2df225eb0b62f52132f301a0df3b2b5928e1ff03ccaa8aec9355349a4929a3d983559b76ccdba3ebb8613b6577130cd3306b9ef9c9c265fd233dc8ebf9c2ce13b1274a00af1d4aa5a8f4045925a6a86964166853f09813e864a7945bd0db2b331a991d2c42e345a317af2e17788a0fede057ab854f55bfcf509c46a638a50601005b73b724ff8371f52f00c453544314dea0dc7d5dffb4c0d71b9484d2776abc601718ef42825503905c2bd34eb43711bb94c7c51487039f84b0f3f31c0beb4440b16eb089efc60dbedcc80b52bbfe10707032bb79e03bbfc49ee4a4908e63b04876d3251492c008e454524e99f94c51cc413dc9d587a40b1594054288a4595049d1d3bfcb0861404925b73326ca44f9cfc3731aa3fb4614e9dcef7cd4f5a931fbfc0d607731edcfb65aee82f24bbc199af1f5452128dd0552a5f0226412a614b59356573fdc0790baa24bf1c048c813dd82cea990a6f6bd0c453e56f6571e56a20c2ad5e8dc6a312b2a960faa827c1654d1b87a5636bbbf30003803f64464e39915d2fb923effebdb2f12f53149e6b00a67f612daa2aedf2ec3862edb832569cda8a76264b898f586b8afb3c239b5a57c6d61ff9ae38b5f6de631cfc23f4fd6726b0488fa0e0cdacd462a8ed9d2e45ec2d2e0c18aa1f11c6748f9581857e37cfab1dd35b5dc4b91981c04266e97d043d9171d420a14e2012a1db1f5f841a44b91183332e5623b037175717062cbc20a2b73d06771b1e170f1955d1e8103dfb94ec8dff95ebfc7201ea338b09f2b7355c50ef62b35814a1b9943527e7ec2ca3b7a15f36ab590e1c883044bc306541c51876f274c797fc24e8ef8e585425486f92e624c1c98de88629f60d3bef65c79f2aa96f76ce9f22cad77e138ed9b83cae0607dd198f4a70c14dae7b513d64a0a67be83616653","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9b090aab28776abb03a7c820bcbb3656"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
