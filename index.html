<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: 6793b0;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: 6793b0;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: 195882;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ACCESS" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea1c40bd749846182ce0f59a33284478b4d65d183547ffc008dadb203983c5aed4519574d77abb5ce90bfb0a487dbb2911acf5f18317aadf3d918f4abe235ed23a564a6441f5845050040ef132e8aa03ef183dad31f50e04f9230f3aaddc42c585384037fc737aa006696935b35bc437205b408db1ea4438f756808e10ec28e9508348b666779eaeb028921d5c957b186e595d2c4ccde105586130d61db751667ba1b99718029787712dc23c40b3725175fce2896f3735ed75c296f99e855d94f8dcb6391f2dd273d9f4cdd0012a29f9f6a0811e5056e4356a74eda36c31fa63267fde9f94f0a04c3f99ba8881f6ea3ad02ae962947168a68723d4479068807e27e8611d1b318c2f84c424464db1c200326ca42c2ab7b4b196f09266a77714dbf668f588c574b71f90520ddcbd3c858c606b8884bb0dbcdb4b133da53f2c212f2ac47b19a909381809318c50ee7644f7a1fe9801de83a4f40b04246cdae96bb996df670f111261cc89a4b48337fdfbb10afc1ec1ec32d8c3acf4665d5c6646e44879cd1f28e7877f2eb8d48568a13a3138d7103cd40b688e1d96eda7cbbb6d77ae5ade788fd2814d1efd209d9d99aae890f68571790f67704e45c28e7ea9d7f4a7b3917def5f46cef214c3083015eff6c63a61e18be4b338b24c4e8c8a5366e04cc5f13e7fc210e03abe49c24f1e5e5a982314516151672a4c7536dd76c32c3acb08c98c516cb92c29aa4e7e0cb0ab7395f101b81a7c6b5924e82263a033bd66cb738f5b29e34c186704e75ce714acddcfd0b98f29e4ce25e01d248364288c632270523db1185c04980dc2a8c497704af7919163ea48ea4ecdc2fd9999ec341c4931f6a577ed0c74bca67445f9734218319903021ad31985b56a97504b2a72496a0076681f33497e1a8423d1a4b5985f8c164bf6baf0c349c3c861dadab43b0206f14541033578fb26c1ed21ca3409676a10e0e9e9a96abcb4cae4121bdbc037c6657283562b8d663ba490353bad4c2334cf2ac41e57e91bc600e5c06909a60a8228bc0c1abed70e838b08c7174412a19d18180827f2c32638349503e03cf87904e78f22ff6ae96cc58e34397b6608db01814d96241d5178976f9471f408e397b9c2b6d2d3bc9c441b979888c91eb0ea1f3147452807f5d010d31f458df0a7f0881614fe944e07fc83152b637c7507f1c632957039a38b81f027c0b9fdded3af84bb9e6ce44af598ebf66dfb6d541446399b90b6e3ba347440c5a19872a785c3b87acfdb6929156c0686a12c59e1c44884b87e63956ef59b442b2f456e2ef095cda4ef7ce340dec63d28bb38c2ca9a2046de371f92c5565335acd71e1e5156ce14ce099b111977b24c656ae4223c9d9e72ca93a13bb12ffb8c65752c4b322df2caf5463d2eddc210644ec19b2083e1a29403df472493a1f76f44e174c3ad6976ccba70125367183696399ce245286fbe60846751e03829cb337744cb65169396dc00aac687482f465f6337b02ff1dc87541e3beebc007fb4e7a0623a54a871df12e9fd9806f5ed053273fc1d50752d4be527ac083f0efdb76b181e503fd44307cb7a0a95659f5ffea4bff229c3ad8cf5fd8baf4a74cad02ad0c020fb70f882d047afd10693a55320d76028dcb9a731b06be2b550e2cf9a30518cab56d0a145a773c8a43b97a26390422020d66a72c7e85429c41875125cf959f844677e378ac1c220e7177bd718cd4e7c91b478ab47a3ecf4169beccf894b0eba9a07a859a01c8248d0466393d9ef0fbbee6263028bb7a829bd07fb66c0b322a4adf4a47e759cffc1776b19665b15f9699f97fe4e0ab9526d86e9216af741cdced3b597f6f44d41c1c06892cc3fe70d61ed0777368f9de7ac447ea6ceb850dc7abe169cbd12b27a53a473ff5bc5223fec7499fad1e207367969a82b186ca9455c1712815e6deed5c82511722e0d3f52612487c907497fecf544462076575b52d85bb97a1e7149fd3db50c472f64db72b63b1ccf3a8f24f7179a60b89e8baaa6bf690bec2a444c944c5ba49594eca948c2f36c676e9e321e2af4b441161531c4d49ba8bd85a71ed53e28210e701a0e4a5752e2628ee1fa1225f8b2b70a7aa89f4fe264d24f7740ec41fbbe59f9a30ac0a36d9271af14e0475f5bfa69a07e20b31ffd9349b7da767aaea7e95357fc064958f70ecce9e75983ba7873c473179fb1ccb72b031be7dafe4c626409f0eb163a418599f16925c4deb71c8889eedee8ca48e613385822d71c7c9a6ac987eb9ff4d6069609d292e4df7b97a692654083888ecc43d3e4cc3e5709defe3c82b2a6bc55e48c7d0c827dd4c2b196155579761f8f57737367f52e9646fcf8584bcc0b73ae513fb00ea84d921642519584d407bc7a6e1189a5d90dd0b018f22776135a64d58689cff3dea8bcd87eb50e5b3b0b86cddd1561e63095873027d93623d4da30463d5716d74625bcf8a6d8bd49244dfc36cb91a30facf06ae9e2317db6ec3e06cb23a253bce8c10bd44f5e5f80f023796db53bbdfd0cd0f4cdd5758596fb21622f11317065ebca07363dca1ced5ba8fa4df66bda82a997d4421ad5f253fe993a24e014f838c5717b8ab5010641f838a591e81a9fcc1222763a70491a69d02501addbdc9e738df25f3078f518fcf3eced6c71a9055271bd2a59c7503c0c82a6320ec3c70293e0742e5bcab580ea501c868a951f3a7d3b6d54550e3d7bff58c92d56a5b04c7ba80ee63bfb8075fb0790cb943a3477a3f8cc6a965c12a86b4b2124a4b5197907b0c52c7ab411214f29f588addaa536b849980ff7050d7a80ce3e28aa712850e8b270fa12ea2bce72b6310e896ae16319e49cfc6e7dd7a3b5a160d5f92c74ebc4582cebe7f04a563c14f3ec68c2b141994c1db0b0314275fdcff199c5800601cdf10727c67f4b85d16d8c8893fc0c9ed68b453fe03193789de9cd0291a8e58d0391d18c84446309e2069e3526340f630f15d118b63e51365d968f537737dc026b3af6a898c6eaa56568279e795501f8f9e55bff4c83e8f9281d9f951198efc69f687f060173282f8a5a64fc52aaf0407c8986ba79b1cd2f73a6613bef85bdd935222dfb941970c8fde2d58fd52976f79edae9ea8b7c91d329d627c4488790da775fe45b12f22b43da4253662659b530c696b75ae17487db9df9042b5b3f52772e6ca45cd867a8bea171a175187ba3a06a9cb10aaedb6d64b9067956df172f90ef0313b789ee956ddb779c305fb1d51c342f178b7aff43d9a046550ca893e86bd43912471741645c33ec4bdec0394b6a7595a2dfae2f2080dd34decbae58cfa4292b4c4636330c8d387f50a191ebc500c8deb4df837d8782b0bdc74d0f4372dc3204a107123eec20420e44767095e19701206dad3e975e01affa5b48658610d65bc3b9fd4ba9a21175181f5129df1b4e73839df898e5945ecc9c943b473ce7b32d8e4fbdec44443b06fee7de4b30767dd507870798c37c07b3017d4f5d38525d6bfaf749e05968056651141d2818221e0c5dc3f2f888d2b5a8b884d86fd059294f10f7c82b16031d2ce064752944ed2123f7e8b167385f25af1edb8e3c5345869195ce4062379041e491fd16449414737d43858508dcec65143592b8cac55b78f4bf493d77120781084eada882e386cbfe75cbd4a688a9d8844b547f5db53671a031099b9a6657d39762dc10991e1f163c7f997be15ffdca6f48168c3a6772d86f0a362c13da0d9a3c3f6c869ae5bdba929089cfc75c1814d52059ca05098f3afc0ee2536b6885404ce3fa55f00c37a2322a25a0686c023ca3558154cb22d4204de73400ccc4a08530bc6edc51d3871ca7ecd84303f68cc1f71a2d94793e30de39b6caab33c473a3d5bc8032e182f6cce6d8853e0478b89fd62ce6c109b280d766fd961683be557db91563df7885a072b9cfda25841f6d0a2f27221635f09a47981c0865e47310e22bab642ea31f65a5cfe321a51ca393fd0dca04b35a8092ee8fbf5622b9ac3dd797eee694668ba5bc4af7bd0057a1489d59bbfe04281efd108bdc84a3b7bf11b9d4d33049047e228a60ccec85405fbe2d342c485f7094b940de2ac0c0eba1d9d36920398ae9e8f55e5f977a137d009a43cd5afd53effaed0509f2b85f94986ffac90ff767d82d97ec33815831302aaa6f1f13f76182dd0c1a7b6ea36ed095fe8709e5c28762bdfeacbc7d658fa2eedc15c2e07ceea1f154b0e417fe005dc4bb4b2f7a16325dd40b2ed2a6c288bf0c5c55d232b07603314c7bf16c8e353833e63f24b7a75466dae939ee91f1c25b219e55d0163c13bbb704199f765c166e92510fcb0dc36515977b02a044f095ed442fea7127b249edd045b1dd430a59f0f83303b051d22695bd275940e5611efbff884f534140feb4fbfa54da305a229f4807f7c104f0716984398b431d24127350c13c12380a119bdfa45ef1d6eb45100b91aefe09a0e18587bbef484f0d304785afa6b9da93f1521b9e0277afd46b95981cc1bb1e003d34b27cb3b3eff01586909741400f2fed00464ea9d896f30f19dff2d4f6acce91370c85dbd4a9512aa7087ae254210c16013543cafe9b40c2631b28d52dc193e568dfff69fab96a7439819072083c91126c97c5456d8f73238022c89eae3791c630d38d78a02c4e5b575ec525f9b987c69cd6eaa70e577720c47b8d080bcb453df5b9f1df775968a600d18bb013b2844aca4930f8d93a52b6e0f05bec3b71abf2727826d816a77f60effe09cfdf4c0e40c90d7e3f83ae6462a3f2023ad3958914ee052b91cd02c9a4be2dd910e33cb849f05c55e9ff41f393bbd6dc532e6adbfb178e933992eff5b515529a6b6a16ca669a48372887349c24f5633aa3c0e24cdc131d35c0d73f4808212bb3d8218e393af345bbab5300c414c274d3275a5b9b4557df7d31e2ebf899f29b0d9e07dcc1a2358607de223940d5d5661697aec918a2278ddf8f882f72547263802cc2cd95f0c4bbefdf79780edf4370e082c7c449e361937bf42c522be9c86ef896bf9f532f418b204db850eb97b1d51a5726bde37a3c282cf29791c7a8b9721cd8adb967707343758b98ba35d7c7c088ae88dd484de90a9cb7b29dbc5e9fffd7deebd77bca818a23b8ee6d17b5bd19c243d067c596ae953662f968911f04cdcfb0194f11b2b0948363706efe5213c56a4b2e9a2a8e45bb3c9885297e6879584c65855bb2d53c8cae909e79811df53042448706e0a00c2d224d23b7add1d9448d3177c3b4d8e8f020fb039f34c9e8f47f8780fb154458aee3a61302768d8c59fe37447db6766cbb668271dffbcf0e25d6da38fed6e58c5ecde3a025d6c144561fbe860507ac228dc17f254381d3f793001b5ba598b9ada1bfe5f0b2910b9117772d007227709c09d4482e66486f3a0a4053da2f97a66950c5d032ec1f3b4041425a2dc178e6ca91a76dd325ead9d04513f2d27021db569445b553fff6db75ec0c5f305daba23ebc8bed71bcd488f721751f3b73974cc846d11a830768abb4022f19800825e018491d64f3b2e48836f19b4ef193a934f1c96d091cb9dcb88760dd30b19bfa1982d01975292f2692d7b5719c4880c7e8b80dcf116bc30d22846cda02b0eacbfd5ae9eaf86ba05fbc200a7be27c64e59e063e7fd5cf46fda97e576165081b0deef1ff80a1889b36ad17e248762d2d560aa869454bbb5cdbc1e2a84313702f418292dae67f010740270b799a8bc22cccba763d1489d03205eac919794cf6c899c5dbc87e66bbd7a2671dfbb2aad8368cad8f09477761cc362eacba3734f41f6358bda17bf3ab6220541f991de9da01699aca335eb3de9d2e785b03e07611ffdb5a8cc48afc93f4dfb7f2e84ae39b965588def4edcb1d6d9c182efe93cb7932fbd9dea9a2e3d8e623b44e93e6d8e7bd2697003e21d3e15e70659b6768e9fa80b9b289f7e3387649f923f99ea252d46e20f3dc959ddf11b511abf574d26641484a8bdb376ae2ce28a3fc60a9d22ab2f23d4aff30384a39286cd85e39ee45fc49e82f3d8e2c40d63a29d0d2043e80bff16d919b8887bcdddaaa2489ac211d40b7c4b7c49060f789cb47dd7bf3e60a13924eb6b6d31c25420a41d9eb56e4faf0c5147ab12e31307b10814d4db2a41b8b95a4966b92877255f0216cb76add35720da3f2ef972f93eb57c67051de9d29e2bd3df08b68d934129bfe4a3525cb2db760ad5fd948f401776c6f729a565842038a87c87a227a9d14b7ad33b4331028497563b0f69b72ac8808102cce319c4ad0ad068beed8bcd471e32e91c1c7c0a6b2f28de6484b4e8b9020d5da8af7e6b49d60152033d151aabd5573f6af77aad978a2a8895918b12d91a571a385604b26e452aa68c94634c9d651a3d3652f649e405af5d89c280cea865c0e8a911d0d497f542d5e457d0f2c5926b677989dc616dda2a830b84d002c4836f00bfc4323e0bad06f20fc0ef95d4336645469e7cb1197b179b3aab0c28538f99c5dda238864efa4344f811c07735ababbf84994a3031a42b06ee23dca22ad2d72a64ba17d65a99b6d2bb31e7d159c6d3ddf37041a07ae0a56985edeb11b2a3cc0a45cdce21b38e1d4d32e26bd9aee122cae01177837af758fe198af67cdd7b0dcc604357c449ce2d91b9ff0745105f54fd0c615b240c168926f07aa5822383c568f8088e394fee6877bddf4ca4c39149a9da8bbf4e4caa4ff0b9b2c56d3a2f18b276332bfeb4985213763b755a3c5424e490111116cb037c506566f39623e465b1142f364022d62a5c10b90069c9f996d93fb472c1e71be39cdd728981cecd9e479f64b50270812141e61e2a9d5efc451801ea3a69ae3f1d61c3cfd7da666ce618a636be9a165c9d0d806c27975b946ba","isRememberEnabled":true,"rememberDurationInDays":"1","staticryptSaltUniqueVariableName":"67a8ff6e5c4086a58b9e1233628ae820"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
